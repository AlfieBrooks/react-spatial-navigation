{"version":3,"sources":["../src/spatialNavigation.js"],"names":["ROOT_FOCUS_KEY","DIRECTION_LEFT","DIRECTION_RIGHT","DIRECTION_UP","DIRECTION_DOWN","KEY_ENTER","DEFAULT_KEY_MAP","SpatialNavigation","direction","sibling","item","itemX","left","itemY","top","itemWidth","width","itemHeight","height","result","resultX","resultY","focusableComponents","focusKey","parentsHavingFocusedChild","enabled","paused","keyEventListener","keyMap","onKeyEvent","bind","pause","resume","setFocus","init","setKeyMap","bindEventHandlers","unbindEventHandlers","window","event","eventType","getKeyMap","code","keyCode","preventDefault","stopPropagation","onEnterPress","addEventListener","removeEventListener","component","onEnterPressHandler","smartNavigate","fromParentFocusKey","currentComponent","parentFocusKey","layout","isVerticalDirection","isIncrementalDirection","coordinate","siblings","currentReferencePoints","getReferencePoints","currentReferenceX","currentReferenceY","sortedSiblings","siblingReferencePoints","siblingReferenceX","siblingReferenceY","Math","sqrt","pow","nextComponent","parentComponent","lastFocusedChildKey","targetFocusKey","targetComponent","children","length","isPropagateFocus","onIntermediateNodeBecameFocused","forgetLastFocusedChild","isFocusableComponent","getNextFocusKey","sortedXChildren","child","sortedYChildren","childKey","node","onBecameFocusedHandler","propagateFocus","onUpdateFocus","onUpdateHasFocusedChild","x","y","updateLayout","componentToRemove","Reflect","deleteProperty","isFocused","oldComponent","newComponent","parents","currentParentFocusKey","push","parentsToRemoveFlag","parentsToAddFlag","getNodeLayoutByFocusKey","overwriteFocusKey","newFocusKey","setCurrentFocusedKey","updateParentsWithFocusedChild","updateAllLayouts"],"mappings":"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","file":"spatialNavigation.js","sourcesContent":["import filter from 'lodash/filter';\nimport first from 'lodash/first';\nimport sortBy from 'lodash/sortBy';\nimport findKey from 'lodash/findKey';\nimport forEach from 'lodash/forEach';\nimport forOwn from 'lodash/forOwn';\nimport difference from 'lodash/difference';\nimport measureLayout from './measureLayout';\n\nexport const ROOT_FOCUS_KEY = 'SN:ROOT';\n\nconst DIRECTION_LEFT = 'left';\nconst DIRECTION_RIGHT = 'right';\nconst DIRECTION_UP = 'up';\nconst DIRECTION_DOWN = 'down';\nconst KEY_ENTER = 'enter';\n\nconst DEFAULT_KEY_MAP = {\n  [DIRECTION_LEFT]: 37,\n  [DIRECTION_UP]: 38,\n  [DIRECTION_RIGHT]: 39,\n  [DIRECTION_DOWN]: 40,\n  [KEY_ENTER]: 13\n};\n\nclass SpatialNavigation {\n  /**\n   * Returns the reference point to be used for directional calculations.\n   * @param direction - Direction which the key press has indicated\n   * @param sibling - whether or not this is a sibling (aka a potential item to move to)\n   * @param item - The layout of the object in question in order to perform calculations\n   */\n  static getReferencePoints(direction, sibling, item) {\n    const itemX = item.left;\n    const itemY = item.top;\n    const itemWidth = item.width;\n    const itemHeight = item.height;\n\n    const result = {\n      resultX: itemX + (itemWidth / 2),\n      resultY: itemY + (itemHeight / 2)\n    };\n\n    switch (direction) {\n    case DIRECTION_RIGHT:\n      result.resultX = sibling ? itemX : itemX + itemWidth;\n      break;\n    case DIRECTION_LEFT:\n      result.resultX = sibling ? itemX + itemWidth : itemX;\n      break;\n    case DIRECTION_UP:\n      result.resultY = sibling ? itemY + itemHeight : itemY;\n      break;\n    case DIRECTION_DOWN:\n      result.resultY = sibling ? itemY : itemY + itemHeight;\n      break;\n    default:\n      break;\n    }\n\n    return result;\n  }\n\n  constructor() {\n    /**\n     * Storage for all focusable components\n     */\n    this.focusableComponents = {};\n\n    /**\n     * Storing current focused key\n     */\n    this.focusKey = null;\n\n    /**\n     * This collection contains focus keys of the elements that are having a child focused\n     * Might be handy for styling of certain parent components if their child is focused.\n     */\n    this.parentsHavingFocusedChild = [];\n\n    this.enabled = false;\n\n    /**\n     * Flag used to block key events from this service\n     * @type {boolean}\n     */\n    this.paused = false;\n\n    this.keyEventListener = null;\n    this.keyMap = DEFAULT_KEY_MAP;\n\n    this.onKeyEvent = this.onKeyEvent.bind(this);\n    this.pause = this.pause.bind(this);\n    this.resume = this.resume.bind(this);\n    this.setFocus = this.setFocus.bind(this);\n    this.init = this.init.bind(this);\n    this.setKeyMap = this.setKeyMap.bind(this);\n  }\n\n  init() {\n    if (!this.enabled) {\n      this.enabled = true;\n      this.bindEventHandlers();\n    }\n  }\n\n  destroy() {\n    if (this.enabled) {\n      this.enabled = false;\n      this.focusKey = null;\n      this.parentsHavingFocusedChild = [];\n      this.focusableComponents = {};\n      this.paused = false;\n      this.keyMap = DEFAULT_KEY_MAP;\n\n      this.unbindEventHandlers();\n    }\n  }\n\n  bindEventHandlers() {\n    if (window) {\n      this.keyEventListener = (event) => {\n        if (this.paused === true) {\n          return;\n        }\n\n        const eventType = findKey(this.getKeyMap(), (code) => event.keyCode === code);\n\n        if (!eventType) {\n          return;\n        }\n\n        if (eventType === KEY_ENTER && this.focusKey) {\n          event.preventDefault();\n          event.stopPropagation();\n\n          this.onEnterPress();\n        } else {\n          event.preventDefault();\n          event.stopPropagation();\n\n          this.onKeyEvent(event.keyCode);\n        }\n      };\n\n      window.addEventListener('keydown', this.keyEventListener);\n    }\n  }\n\n  unbindEventHandlers() {\n    if (window) {\n      window.removeEventListener('keydown', this.keyEventListener);\n      this.keyEventListener = null;\n    }\n  }\n\n  onEnterPress() {\n    const component = this.focusableComponents[this.focusKey];\n\n    component.onEnterPressHandler && component.onEnterPressHandler();\n  }\n\n  onKeyEvent(keyCode) {\n    const direction = findKey(this.getKeyMap(), (code) => keyCode === code);\n\n    this.smartNavigate(direction);\n  }\n\n  /**\n   * This function navigates between siblings OR goes up by the Tree\n   * Based on the Direction\n   */\n  smartNavigate(direction, fromParentFocusKey) {\n    const currentComponent = this.focusableComponents[fromParentFocusKey || this.focusKey];\n\n    if (currentComponent) {\n      const {parentFocusKey, focusKey, layout} = currentComponent;\n\n      const isVerticalDirection = direction === DIRECTION_DOWN || direction === DIRECTION_UP;\n      const isIncrementalDirection = direction === DIRECTION_DOWN || direction === DIRECTION_RIGHT;\n\n      const coordinate = isVerticalDirection ? 'top' : 'left';\n\n      /**\n       * Get only the siblings with the coords on the way of our moving direction\n       */\n      const siblings = filter(this.focusableComponents, (component) => component.parentFocusKey === parentFocusKey &&\n        ((isIncrementalDirection && component.layout[coordinate] > layout[coordinate]) ||\n          (!isIncrementalDirection && component.layout[coordinate] < layout[coordinate])));\n\n      const currentReferencePoints = SpatialNavigation.getReferencePoints(direction, false, layout);\n      const currentReferenceX = currentReferencePoints.resultX;\n      const currentReferenceY = currentReferencePoints.resultY;\n\n      const sortedSiblings = sortBy(siblings, (sibling) => {\n        const siblingReferencePoints = SpatialNavigation.getReferencePoints(direction, true, sibling.layout);\n        const siblingReferenceX = siblingReferencePoints.resultX;\n        const siblingReferenceY = siblingReferencePoints.resultY;\n\n        return Math.sqrt(Math.pow((siblingReferenceX - currentReferenceX), 2) +\n          Math.pow((siblingReferenceY - currentReferenceY), 2));\n      });\n\n      const nextComponent = first(sortedSiblings);\n\n      if (nextComponent) {\n        this.setFocus(nextComponent.focusKey);\n      } else {\n        const parentComponent = this.focusableComponents[parentFocusKey];\n\n        parentComponent && (parentComponent.lastFocusedChildKey = focusKey);\n\n        this.smartNavigate(direction, parentFocusKey);\n      }\n    }\n  }\n\n  /**\n   * This function tries to determine the next component to Focus\n   * It's either the target node OR the one down by the Tree if node has \"propagateFocus\"\n   * Based on \"targetFocusKey\"\n   */\n  getNextFocusKey(targetFocusKey) {\n    const targetComponent = this.focusableComponents[targetFocusKey];\n\n    /**\n     * Security check, if component doesn't exist, stay on the same focusKey\n     */\n    if (!targetComponent) {\n      return targetFocusKey;\n    }\n\n    const children = filter(this.focusableComponents, (component) => component.parentFocusKey === targetFocusKey);\n\n    if (children.length > 0 && this.isPropagateFocus(targetFocusKey)) {\n      this.onIntermediateNodeBecameFocused(targetFocusKey);\n\n      /**\n       * First of all trying to focus last focused child\n       */\n      const {lastFocusedChildKey} = targetComponent;\n\n      if (lastFocusedChildKey &&\n        !targetComponent.forgetLastFocusedChild &&\n        this.isFocusableComponent(lastFocusedChildKey)\n      ) {\n        return this.getNextFocusKey(lastFocusedChildKey);\n      }\n\n      /**\n       * If there is no lastFocusedChild, trying to focus something by coordinates\n       */\n      const sortedXChildren = sortBy(children, (child) => child.layout.left);\n      const sortedYChildren = sortBy(sortedXChildren, (child) => child.layout.top);\n      const {focusKey: childKey} = first(sortedYChildren);\n\n      return this.getNextFocusKey(childKey);\n    }\n\n    /**\n     * If no children, just return targetFocusKey back\n     */\n    return targetFocusKey;\n  }\n\n  addFocusable({\n    focusKey,\n    node,\n    parentFocusKey,\n    onEnterPressHandler,\n    onBecameFocusedHandler,\n    forgetLastFocusedChild,\n    propagateFocus,\n    onUpdateFocus,\n    onUpdateHasFocusedChild\n  }) {\n    this.focusableComponents[focusKey] = {\n      focusKey,\n      node,\n      parentFocusKey,\n      onEnterPressHandler,\n      onBecameFocusedHandler,\n      onUpdateFocus,\n      onUpdateHasFocusedChild,\n      propagateFocus,\n      forgetLastFocusedChild,\n      lastFocusedChildKey: null,\n      layout: {\n        x: 0,\n        y: 0,\n        width: 0,\n        height: 0,\n        left: 0,\n        top: 0\n      }\n    };\n\n    this.updateLayout(focusKey);\n\n    /**\n     * If for some reason this component was already focused before it was added, call the update\n     */\n    if (focusKey === this.focusKey) {\n      this.setFocus(focusKey);\n    }\n  }\n\n  removeFocusable({focusKey}) {\n    const componentToRemove = this.focusableComponents[focusKey];\n\n    if (componentToRemove) {\n      const {parentFocusKey} = componentToRemove;\n\n      Reflect.deleteProperty(this.focusableComponents, focusKey);\n\n      const parentComponent = this.focusableComponents[parentFocusKey];\n      const isFocused = focusKey === this.focusKey;\n\n      /**\n       * If the component was stored as lastFocusedChild, clear lastFocusedChildKey from parent\n       */\n      parentComponent && parentComponent.lastFocusedChildKey === focusKey &&\n        (parentComponent.lastFocusedChildKey = null);\n\n      /**\n       * If the component was also focused at this time, focus another one\n       */\n      if (isFocused) {\n        this.setFocus(parentFocusKey);\n      }\n    }\n  }\n\n  getNodeLayoutByFocusKey(focusKey) {\n    const component = this.focusableComponents[focusKey];\n\n    if (component) {\n      return component.layout;\n    }\n\n    return null;\n  }\n\n  setCurrentFocusedKey(focusKey) {\n    if (this.isFocusableComponent(this.focusKey) && focusKey !== this.focusKey) {\n      const oldComponent = this.focusableComponents[this.focusKey];\n\n      oldComponent.onUpdateFocus(false);\n    }\n\n    this.focusKey = focusKey;\n\n    const newComponent = this.focusableComponents[this.focusKey];\n\n    newComponent && newComponent.onUpdateFocus(true);\n  }\n\n  updateParentsWithFocusedChild(focusKey) {\n    const parents = [];\n\n    let currentComponent = this.focusableComponents[focusKey];\n\n    /**\n     * Recursively iterate the tree up and find all the parents' focus keys\n     */\n    while (currentComponent) {\n      const {parentFocusKey} = currentComponent;\n\n      const parentComponent = this.focusableComponents[parentFocusKey];\n\n      if (parentComponent) {\n        const {focusKey: currentParentFocusKey} = parentComponent;\n\n        parents.push(currentParentFocusKey);\n      }\n\n      currentComponent = parentComponent;\n    }\n\n    const parentsToRemoveFlag = difference(this.parentsHavingFocusedChild, parents);\n    const parentsToAddFlag = difference(parents, this.parentsHavingFocusedChild);\n\n    forEach(parentsToRemoveFlag, (parentFocusKey) => {\n      const parentComponent = this.focusableComponents[parentFocusKey];\n\n      parentComponent && parentComponent.onUpdateHasFocusedChild(false);\n    });\n\n    forEach(parentsToAddFlag, (parentFocusKey) => {\n      const parentComponent = this.focusableComponents[parentFocusKey];\n\n      parentComponent && parentComponent.onUpdateHasFocusedChild(true);\n    });\n\n    this.parentsHavingFocusedChild = parents;\n  }\n\n  getKeyMap() {\n    return this.keyMap;\n  }\n\n  setKeyMap(keyMap) {\n    this.keyMap = {\n      ...this.getKeyMap(),\n      ...keyMap\n    };\n  }\n\n  isPropagateFocus(focusKey) {\n    return this.isFocusableComponent(focusKey) && this.focusableComponents[focusKey].propagateFocus;\n  }\n\n  isFocusableComponent(focusKey) {\n    return !!this.focusableComponents[focusKey];\n  }\n\n  onIntermediateNodeBecameFocused(focusKey) {\n    this.isFocusableComponent(focusKey) &&\n      this.focusableComponents[focusKey].onBecameFocusedHandler(this.getNodeLayoutByFocusKey(focusKey));\n  }\n\n  pause() {\n    this.paused = true;\n  }\n\n  resume() {\n    this.paused = false;\n  }\n\n  setFocus(focusKey, overwriteFocusKey) {\n    if (!this.enabled) {\n      return;\n    }\n\n    const targetFocusKey = overwriteFocusKey && this.isFocusableComponent(overwriteFocusKey) ?\n      overwriteFocusKey : focusKey;\n\n    const newFocusKey = this.getNextFocusKey(targetFocusKey);\n\n    this.setCurrentFocusedKey(newFocusKey);\n    this.updateParentsWithFocusedChild(newFocusKey);\n    this.updateAllLayouts();\n  }\n\n  updateAllLayouts() {\n    forOwn(this.focusableComponents, (component, focusKey) => {\n      this.updateLayout(focusKey);\n    });\n  }\n\n  updateLayout(focusKey) {\n    const component = this.focusableComponents[focusKey];\n\n    if (!component) {\n      return;\n    }\n\n    const {node} = component;\n\n    measureLayout(node, (x, y, width, height, left, top) => {\n      component.layout = {\n        x,\n        y,\n        width,\n        height,\n        left,\n        top\n      };\n    });\n  }\n}\n\n/**\n * Export singleton\n */\nexport default new SpatialNavigation();\n"]}